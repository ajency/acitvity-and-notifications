{
  "name": "di-lite",
  "version": "0.3.3",
  "description": "A ultra light-weight dependency injection container in Javascript ",
  "keywords": [
    "di",
    "ioc",
    "ioc container",
    "dependency management",
    "dependency injection",
    "di container"
  ],
  "homepage": "http://nickqizhu.github.com/di.js/",
  "author": {
    "name": "Nick Zhu",
    "url": "http://nzhu.blogspot.ca/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/NickQiZhu/di.js.git"
  },
  "dependencies": {},
  "devDependencies": {
    "uglify-js": "2.x",
    "jasmine-node": "1.x",
    "jquery": "1.x",
    "sinon": "1.x",
    "backbone": "0.9.x"
  },
  "scripts": {
    "test": "./node_modules/jasmine-node/bin/jasmine-node spec"
  },
  "readme": "[![build status](https://secure.travis-ci.org/NickQiZhu/di.js.png)](http://travis-ci.org/NickQiZhu/di.js)\n\ndi-lite.js\n==========\n\ndi-lite is designed to act as a minimalistic dependency injection container in Javascript. It has no dependency on\nany other framework such as CommonJs or RequireJs in contrary to some of other more heavy weight DI container\nimplementation on the web.\n\nUse Cases\n---------\n\ndi-lite was initially extracted from a Backbone.js based application. In this application, RequireJs was used to wire\ndependencies at module level. Each module could contain multiple views and models. We found using RequireJs to wire\nevery individual view and model is a bit of overkill and verbose, however we still want the inversion of control to\nkeep our code nicely isolated and testable. That's the reason behind the creation of this lightweight container\nimplementation - to provide dependencies injection at sub-modular level.\n\nThat being said di-lite is designed to be used standalone there is no dependency on Backbone or RequireJs. Its a fully\nfunctional dependency injection container by itself while extremely lightweight and works well both in browser or node.\n\n\nInstall with npm\n--------------------\nnpm install di-lite\n\n\nInstall without npm\n--------------------\nDownload\n* [di-lite](https://github.com/NickQiZhu/di.js)\n\nHow-to Guide\n------------\n\n* [Basic Wiring](#basic-wiring)\n* [Wiring with Assignment](#wiring-with-assignment)\n* [Passive Dependency Resolution](#passive-dependency-resolution)\n* [Singleton By Default](#singleton-by-default)\n* [Prototype Strategy](#prototype-strategy)\n* [Passing Constructor Arguments](#passing-constructor-arguments)\n* [Cyclical Dependency](#cyclical-dependency)\n* [Functional Object](#functional-object)\n* [Lifecycle Hook](#lifecycle-hook)\n* [Runtime Dependencies Override](runtime-dependencies-override)\n* [Create Your Own](#create-your-own)\n\n### Basic Wiring\n\n```js\nvar A = function(){\n    ...\n    this.dependencies = \"b, c\";\n    ...\n};\nvar B = function(){\n    ...\n    this.dependencies = \"c\";\n    ...\n};\nvar C = funciton(){...};\n\n// create di context\nvar ctx = di.createContext();\n\n// register a class with an unique name\nctx.register(\"a\", A);\nctx.register(\"b\", B);\nctx.register(\"c\", C);\n\n// initialize di container so all singleton(default) objects will be wired at this stage\nctx.initialize();\n\nvar instanceOfA = ctx.get(\"a\");\ninstaceOfA.b === ctx.get(\"b\"); // true\ninstaceOfA.c === ctx.get(\"c\"); // true\n\nvar instanceOfB = ctx.get(\"b\");\ninstanceOfB.c === ctx.get(\"c\"); // true\n```\n### Wiring with Assignment\nBy default dependencies are wired using their registered name respectively, however you can override this behavior by\nincluding an explicit assignment in dependency definition. You can also mix both explicit and implicit assignment in\ndependency definition.\n\n```js\nvar A = function(){\n    ...\n    this.dependencies = \"bee=b, c\"; // mix explicit and implicit assignment\n    ...\n};\n\nctx.initialize();\n\nvar instanceOfA = ctx.get(\"a\");\ninstaceOfA.bee === ctx.get(\"b\"); // true - explicit assignment\ninstaceOfA.c === ctx.get(\"c\"); // true - implicit assignment\n```\n\n### Passive Dependency Resolution\ndi-lite container resolves dependency passively on demand when ```get()``` method is invoked. It only tries to resolve\ndependency for this particular object thus only traverse its sub-dependency-tree. ```initialize()``` call does resolve\nall dependencies for all registered objects however it is actually optional (though recommended to guarantee).\n\n```js\nctx.register(\"a\", A);\nctx.get(\"a\"); // this triggers the dependency resolution for \"a\" alone\nctx.initialize(); // this triggers the dependency resolution for everyone registered\n```\n\n### Singleton By Default\n\nAll objects created and managed by di-lite.js container are by default singleton.\n\n```js\nctx.get(\"a\") === ctx.get(\"a\"); // true\n```\n\n### Prototype Strategy\n\nIf you want container to create a new instance of your class each time you invoke ```get``` method then you need\nto configure your registration with ```di.strategy.proto``` cache strategy.\n\n```js\nctx.register(\"prototype\", A).strategy(di.strategy.proto);\nctx.get(\"prototype\") === ctx.get(\"prototype\"); // false\nctx.create(\"prototype\", 100); // create can be used if you want to explicitly pass in a new parameter\n```\n\n### Passing Constructor Arguments\n\nYou can pass arguments to constructor function by using the additional parameter in ```register``` call.\n\n```js\nctx.register(\"str\", String, \"hello world\"); // signle simple argument\nctx.register(\"profileView\", ProfileView, {el: \"#profile_div\"}); // signle object literal argument\nctx.register(\"array\", Array, [\"Saab\",\"Volvo\",\"BMW\"]); // multiple argument is passed in using an array\n```\n\n### Cyclical Dependency\n\ndi-lite.js container supports solution of cyclical dependencies, so the following dependency relationship is valid.\n\n```js\nvar A = function(){\n    ...\n    this.dependencies = \"b\";\n    ...\n};\nvar B = function(){\n    ...\n    this.dependencies = \"a\";\n    ...\n};\n\nctx.register(\"a\", A);\nctx.register(\"b\", B);\n\nctx.initialize();\n\nctx.get(\"a\").b === ctx.get(\"b\"); // true\nctx.get(\"b\").a === ctx.get(\"a\"); // true\nctx.get(\"a\").b.a === ctx.get(\"a\"); // true\nctx.get(\"b\").a.b === ctx.get(\"b\"); // true\n```\n\n### Functional Object\n\nWhat if your are using functional object pattern and do not have a constructor function for your object? di-lite.js fully\nsupports functional object pattern since we believe this is the best way to create javascript object anyway.\n\n```js\nvar FuncObject = function(spec){\n    var that = {};\n    ...\n    return that;\n};\n\nctx.register(\"funcObjSingleton\", FuncObject, spec).factory(di.factory.func);\n\n// function chaining can be used to customize your object registration\nctx.register(\"funcObjProto\", FuncObject, spec)\n    .strategy(di.strategy.proto)\n    .factory(di.factory.func);\n\nctx.initialize();\n\nctx.get(\"funcObjSingleton\"); // will return you a signleton instance of FuncObject\nctx.get(\"funcObjProto\"); // will return you a new instance of FuncObject each time\n```\n\n### Lifecycle Hook\n\ndi-lite container provides a lifecycle hook callback ```ready``` if the wired object provide a ```ready``` function\nthen the callback will be executed once all dependencies are satisfied.\n\n```js\nvar MyView = Backbone.View.extend({\n    ...\n    dependencies: \"otherView, myModel\",\n    ready: function(){this.render();} // called once all dependencies are satisfied\n    ...\n});\n```\n\n### Runtime Dependencies Override\nWhat if I need to provide different dependencies different instances of the same class?\n\n```js\nctx.register(\"a\", A)\n    .dependencies(\"bee=b\"); // dependencies specified here will take precedence\n...\nctx.get(\"a\").bee === ctx.get(\"b\"); // true\n```\n\n### Create Your Own\n\nSometimes you just don't have control over the object you want to wire or maybe you need to create the object\nand initialize before anything else is create or even registered. You can manually insert object into di-lite\ncontainer and control the whole creation process this way.\n\n```js\nctx.register(\"history\").object(Backbone.history);\n...\nctx.get(\"history\").start(); // you can use it since it is already created and initialized\n...\nctx.initialize(); // initialize the rest of the objects\n```\n\nHow to build di-lite locally\n---------------------------\n\n### Prerequisite modules\n\nMake sure the following packages are installed on your machine\n* node.js\n* npm\n* apache ant\n\n### Install dependencies\n\ndi-lite$ npm install\n\n### Build and Test\n\ndi-lite$ ./make\n\n\nLicense\n--------------------\n\ndi-lite is an open source javascript library and licensed under\n[Apache License v2](http://www.apache.org/licenses/LICENSE-2.0.html).\n",
  "readmeFilename": "README.md",
  "_id": "di-lite@0.3.3",
  "dist": {
    "shasum": "25b29c78fb2eaf769217f4c580be043dfb0abbdb",
    "tarball": "http://registry.npmjs.org/di-lite/-/di-lite-0.3.3.tgz"
  },
  "_from": "di-lite@^0.3.3",
  "_npmVersion": "1.2.14",
  "_npmUser": {
    "name": "nick.qi.zhu",
    "email": "nick.qi.zhu@gmail.com"
  },
  "maintainers": [
    {
      "name": "nick.qi.zhu",
      "email": "nick.qi.zhu@gmail.com"
    },
    {
      "name": "leotcsun",
      "email": "leo.tcsun@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "25b29c78fb2eaf769217f4c580be043dfb0abbdb",
  "_resolved": "https://registry.npmjs.org/di-lite/-/di-lite-0.3.3.tgz",
  "bugs": {
    "url": "https://github.com/NickQiZhu/di.js/issues"
  }
}
